package org.kuali.core.db.torque;

import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.sql.Array;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.torque.engine.database.model.TypeMap;
import org.apache.xerces.dom.DocumentImpl;
import org.apache.xerces.dom.DocumentTypeImpl;
import org.apache.xml.serialize.Method;
import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.XMLSerializer;
import org.w3c.dom.Element;

public class KualiTorqueJDBCTransformTask extends Task {
    /** Name of XML database schema produced. */
    protected String xmlSchema;

    /** JDBC URL. */
    protected String dbUrl;

    /** JDBC driver. */
    protected String dbDriver;

    /** JDBC user name. */
    protected String dbUser;

    /** JDBC password. */
    protected String dbPassword;

    /** DB schema to use. */
    protected String dbSchema;

    /** DOM document produced. */
    protected DocumentImpl doc;

    /** The document root element. */
    protected Element databaseNode;

    /** Hashtable of columns that have primary keys. */
    protected Hashtable primaryKeys;

    /** Hashtable to track what table a column belongs to. */
    protected Hashtable columnTableMap;

    protected boolean sameJavaName;

    private XMLSerializer xmlSerializer;

    public String getDbSchema()
    {
        return dbSchema;
    }

    public void setDbSchema(String dbSchema)
    {
        this.dbSchema = dbSchema;
    }

    public void setDbUrl(String v)
    {
        dbUrl = v;
    }

    public void setDbDriver(String v)
    {
        dbDriver = v;
    }

    public void setDbUser(String v)
    {
        dbUser = v;
    }

    public void setDbPassword(String v)
    {
        dbPassword = v;
    }

    public void setOutputFile (String v)
    {
        xmlSchema = v;
    }

    public void setSameJavaName(boolean v)
    {
        this.sameJavaName = v;
    }

    public boolean isSameJavaName()
    {
        return this.sameJavaName;
    }

    /**
     * Default constructor.
     *
     * @throws BuildException
     */
    public void execute() throws BuildException
    {
        log("Torque - JDBCToXMLSchema starting");
        log("Your DB settings are:");
        log("driver : " + dbDriver);
        log("URL : " + dbUrl);
        log("user : " + dbUser);
        // log("password : " + dbPassword);
        log("schema : " + dbSchema);

        DocumentTypeImpl docType = new DocumentTypeImpl(null, "database", null, "database.dtd" );
        doc = new DocumentImpl(docType);
        doc.appendChild(doc.createComment(
                " Autogenerated by KualiTorqueJDBCTransformTask! "));

        try
        {
            generateXML();
            log(xmlSchema);
            xmlSerializer = new XMLSerializer(
                    new PrintWriter( new FileOutputStream(xmlSchema) ),
                    new OutputFormat(Method.XML, null, true));
            xmlSerializer.serialize(doc);
        }
        catch (Exception e)
        {
            throw new BuildException(e);
        }
        log("Torque - JDBCToXMLSchema finished");
    }

	/**
	 * Generates an XML database schema from JDBC metadata.
	 * 
	 * @throws Exception
	 *             a generic exception.
	 */
	public void generateXML() throws Exception {
		// Load the database Driver.
		Class.forName( dbDriver );
		log( "DB driver sucessfuly instantiated" );

		Connection con = null;
		try {
			// Attempt to connect to a database.
			con = DriverManager.getConnection( dbUrl, dbUser, dbPassword );
			log( "DB connection established" );

			// Get the database Metadata.
			DatabaseMetaData dbMetaData = con.getMetaData();

			// The database map.
			List tableList = getTableNames( dbMetaData );
			
			databaseNode = doc.createElement( "database" );
			databaseNode.setAttribute( "name", dbUser );
			// JHK added naming method
			databaseNode.setAttribute( "defaultJavaNamingMethod", "nochange" );

			// Build a database-wide column -> table map.
			columnTableMap = new Hashtable();

			log( "Building column/table map..." );
			for ( int i = 0; i < tableList.size(); i++ ) {
				String curTable = (String)tableList.get( i );
				List columns = getColumns( dbMetaData, curTable );

				for ( int j = 0; j < columns.size(); j++ ) {
					List col = (List)columns.get( j );
					String name = (String)col.get( 0 );

					columnTableMap.put( name, curTable );
				}
			}

			for ( int i = 0; i < tableList.size(); i++ ) {
				// Add Table.
				String curTable = (String)tableList.get( i );
				// dbMap.addTable(curTable);
				log( "Processing table: " + curTable );

				Element table = doc.createElement( "table" );
				table.setAttribute( "name", curTable );
				if ( isSameJavaName() ) {
					table.setAttribute( "javaName", curTable );
				}

				// Add Columns.
				// TableMap tblMap = dbMap.getTable(curTable);

				List columns = getColumns( dbMetaData, curTable );
				List primKeys = getPrimaryKeys( dbMetaData, curTable );
				Map<String,Object[]> forgnKeys = getForeignKeys( dbMetaData, curTable );

				// Set the primary keys.
				primaryKeys = new Hashtable();

				for ( int k = 0; k < primKeys.size(); k++ ) {
					String curPrimaryKey = (String)primKeys.get( k );
					primaryKeys.put( curPrimaryKey, curPrimaryKey );
				}

				for ( int j = 0; j < columns.size(); j++ ) {
					List col = (List)columns.get( j );
					String name = (String)col.get( 0 );
					Integer type = ((Integer)col.get( 1 ));
					int size = ((Integer)col.get( 2 )).intValue();
					int scale = ((Integer)col.get( 5 )).intValue();

					// From DatabaseMetaData.java
					//
					// Indicates column might not allow NULL values. Huh?
					// Might? Boy, that's a definitive answer.
					/* int columnNoNulls = 0; */

					// Indicates column definitely allows NULL values.
					/* int columnNullable = 1; */

					// Indicates NULLABILITY of column is unknown.
					/* int columnNullableUnknown = 2; */

					Integer nullType = (Integer)col.get( 3 );
					String defValue = (String)col.get( 4 );

					Element column = doc.createElement( "column" );
					column.setAttribute( "name", name );
					if ( isSameJavaName() ) {
						column.setAttribute( "javaName", name );
					}

					column.setAttribute( "type", TypeMap.getTorqueType( type )
							.getName() );

					if ( size > 0 &&
							(type.intValue() == Types.CHAR ||
									type.intValue() == Types.VARCHAR ||
									type.intValue() == Types.LONGVARCHAR ||
									type.intValue() == Types.DECIMAL || type
									.intValue() == Types.NUMERIC) ) {
						column.setAttribute( "size", String.valueOf( size ) );
					}

					if ( scale > 0 &&
							(type.intValue() == Types.DECIMAL || type
									.intValue() == Types.NUMERIC) ) {
						column.setAttribute( "scale", String.valueOf( scale ) );
					}

					if ( primaryKeys.containsKey( name ) ) {
						column.setAttribute( "primaryKey", "true" );
						// JHK: protect MySQL from excessively long column in the PK
						//System.out.println( curTable + "." + name + " / " + size );
						if ( column.getAttribute( "size" ) != null 
								&& size > 765 ) {
							System.out.println( "updating column " + curTable + "." + name + " length from " + size + " to 255" );
							column.setAttribute( "size", "255" );
						}
					} else {
						if ( nullType.intValue() == DatabaseMetaData.columnNoNulls ) {
							column.setAttribute( "required", "true" );
						}
					}

					if ( StringUtils.isNotEmpty( defValue ) ) {
						defValue = defValue.trim();
						// trim out parens & quotes out of def value.
						// makes sense for MSSQL. not sure about others.
						if ( defValue.startsWith( "(" ) &&
								defValue.endsWith( ")" ) ) {
							defValue = defValue.substring( 1,
									defValue.length() - 1 );
						}

						if ( defValue.startsWith( "'" ) &&
								defValue.endsWith( "'" ) ) {
							defValue = defValue.substring( 1,
									defValue.length() - 1 );
						}
						if ( defValue.equals( "NULL" ) ) {
							defValue = "";
						}
						if ( StringUtils.isNotEmpty( defValue ) ) {
							column.setAttribute( "default", defValue );
						}
					}
					table.appendChild( column );
				}

				// Foreign keys for this table.
				for ( String fkName : forgnKeys.keySet() ) {
					Element fk = doc.createElement( "foreign-key" );
					fk.setAttribute(  "name", fkName );
					Object[] forKey = forgnKeys.get( fkName );
					String foreignKeyTable = (String)forKey[0];
					List refs = (List)forKey[1];
					fk.setAttribute( "foreignTable", foreignKeyTable );
					String onDelete = (String) forKey[2];
					// gmcgrego - just adding onDelete if it's cascade so as not to affect kfs behavior
					if (onDelete == "cascade") {
						fk.setAttribute("onDelete", onDelete);
					}
					for ( int m = 0; m < refs.size(); m++ ) {
						Element ref = doc.createElement( "reference" );
						String[] refData = (String[])refs.get( m );
						ref.setAttribute( "local", refData[0] );
						ref.setAttribute( "foreign", refData[1] );
						fk.appendChild( ref );
					}
					table.appendChild( fk );
				}
				
				for ( TableIndex idx : getIndexes( dbMetaData, curTable ) ) {
					String tagName = idx.unique?"unique":"index";
					Element index = doc.createElement( tagName );
					index.setAttribute( "name", idx.name );
					for ( String colName : idx.columns ) {
						Element col = doc.createElement( tagName + "-column" );
						col.setAttribute( "name", colName );
						index.appendChild( col );
					}
					table.appendChild( index );
				}
				
				databaseNode.appendChild( table );
			}
			List<String> viewNames = getViewNames( dbMetaData );
			for ( String viewName : viewNames ) {
				Element view = doc.createElement( "view" );
				view.setAttribute( "name", viewName );
				/*
				 * <view name="" viewdefinition="" />
				 * 
				 */
				String definition = "";
				if ( dbMetaData.getDatabaseProductName().equalsIgnoreCase( "oracle" ) ) {
					PreparedStatement ps = dbMetaData.getConnection().prepareStatement( "SELECT text FROM all_views WHERE owner = ? AND view_name = ?" );
					ps.setString( 1, dbSchema );
					ps.setString( 2, viewName );
					ResultSet rs = ps.executeQuery();
					if ( rs.next() ) {
						definition = rs.getString( 1 );
					}
					rs.close();
					ps.close();						
				} else if ( dbMetaData.getDatabaseProductName().equalsIgnoreCase( "mysql" ) ) {
					PreparedStatement ps = dbMetaData.getConnection().prepareStatement( "SELECT view_definition FROM information_schema.views WHERE table_schema = ? AND table_name = ?" );
					ps.setString( 1, dbSchema );
					ps.setString( 2, viewName );
					ResultSet rs = ps.executeQuery();
					if ( rs.next() ) {
						definition = rs.getString( 1 );
					}
					rs.close();
					ps.close();						
				}
				// remove binary zeroes that Oracle is adding to the end of the definition
				definition = definition.replaceAll( "\0", "" );
				view.setAttribute( "viewdefinition", definition );
				databaseNode.appendChild( view );
			}
			List<String> sequenceNames = getSequenceNames( dbMetaData );
			for ( String sequenceName : sequenceNames ) {
				Element sequence = doc.createElement( "sequence" );
				sequence.setAttribute( "name", sequenceName );
				/*
				 * <view name="" nextval="" />
				 * 
				 */
				String nextVal = "0";
				if ( dbMetaData.getDatabaseProductName().equalsIgnoreCase( "oracle" ) ) {
					PreparedStatement ps = dbMetaData.getConnection().prepareStatement( "SELECT last_number FROM all_sequences WHERE sequence_owner = ? AND sequence_name = ?" );
					ps.setString( 1, dbSchema );
					ps.setString( 2, sequenceName );
					ResultSet rs = ps.executeQuery();
					if ( rs.next() ) {
						nextVal = rs.getString( 1 );
					}
					rs.close();
					ps.close();						
				} else if ( dbMetaData.getDatabaseProductName().equalsIgnoreCase( "mysql" ) ) { 
					PreparedStatement ps = dbMetaData.getConnection().prepareStatement( "SELECT id FROM " + sequenceName );
					ResultSet rs = ps.executeQuery();
					if ( rs.next() ) {
						nextVal = rs.getString( 1 );
					}
					rs.close();
					ps.close();						
				} else {
					System.err.println( "Unknown DB type: " + dbMetaData.getDatabaseProductName() );
				}
				sequence.setAttribute( "nextval", nextVal );
				
				databaseNode.appendChild( sequence );
			}
			doc.appendChild( databaseNode );
		} finally {
			if ( con != null ) {
				con.close();
				con = null;
			}
		}
	}

	/**
	 * Get all the table names in the current database that are not system
	 * tables.
	 * 
	 * @param dbMeta
	 *            JDBC database metadata.
	 * @return The list of all the tables in a database.
	 * @throws SQLException
	 */
	public List getTableNames(DatabaseMetaData dbMeta) throws SQLException {
		log( "Getting table list..." );
		List tables = new ArrayList();
		ResultSet tableNames = null;
		// these are the entity types we want from the database
		String[] types = { "TABLE", "SEQUENCE" }; // JHK: removed views from list
		try {
			tableNames = dbMeta.getTables( null, dbSchema, null, types );
			while ( tableNames.next() ) {
				String name = tableNames.getString( 3 );
				if ( !isSequence( name ) ) {
					tables.add( name );
				}
			}
		} finally {
			if ( tableNames != null ) {
				tableNames.close();
			}
		}
		log( "Found " + tables.size() + " tables." );
		return tables;
	}

	public List getViewNames(DatabaseMetaData dbMeta) throws SQLException {
		log( "Getting view list..." );
		List tables = new ArrayList();
		ResultSet tableNames = null;
		// these are the entity types we want from the database
		String[] types = { "VIEW" }; // JHK: removed views from list
		try {
			tableNames = dbMeta.getTables( null, dbSchema, null, types );
			System.out.println();				
			while ( tableNames.next() ) {
				String name = tableNames.getString( 3 );
				tables.add( name );
			}
		} finally {
			if ( tableNames != null ) {
				tableNames.close();
			}
		}
		log( "Found " + tables.size() + " views." );
		return tables;
	}
	
	public boolean isSequence( String sequenceName ) {
		return sequenceName.toUpperCase().startsWith( "SEQ_" ) 
				|| sequenceName.toUpperCase().startsWith( "SEQUENCE_" ) 
				|| sequenceName.toUpperCase().endsWith( "_SEQ" ) 
				|| sequenceName.toUpperCase().endsWith( "_SEQUENCE" )
				|| sequenceName.toUpperCase().endsWith( "_ID" ) ;
	}
	
	public List getSequenceNames(DatabaseMetaData dbMeta) throws SQLException {
		log( "Getting sequence list..." );
		List tables = new ArrayList();
		ResultSet tableNames = null;
		// these are the entity types we want from the database
		String[] types = { "TABLE", "SEQUENCE" }; // JHK: removed views from list
		try {
			tableNames = dbMeta.getTables( null, dbSchema, null, types );
			while ( tableNames.next() ) {
				String name = tableNames.getString( 3 );
				if ( isSequence( name ) ) {
					tables.add( name );
				}
			}
		} finally {
			if ( tableNames != null ) {
				tableNames.close();
			}
		}		
		log( "Found " + tables.size() + " sequences." );
		return tables;
	}
//	for ( int i = 1; i <= tableNames.getMetaData().getColumnCount(); i++ ) {
//		System.out.print( tableNames.getMetaData().getColumnName( i ) + "," );				
//	}
//	System.out.println();				
//	for ( int i = 1; i <= tableNames.getMetaData().getColumnCount(); i++ ) {
//		System.out.print( tableNames.getString( i ) + "," );				
//	}
//	System.out.println();				


    /**
     * Retrieves all the column names and types for a given table from
     * JDBC metadata.  It returns a List of Lists.  Each element
     * of the returned List is a List with:
     *
     * element 0 => a String object for the column name.
     * element 1 => an Integer object for the column type.
     * element 2 => size of the column.
     * element 3 => null type.
     *
     * @param dbMeta JDBC metadata.
     * @param tableName Table from which to retrieve column information.
     * @return The list of columns in <code>tableName</code>.
     * @throws SQLException
     */
    public List getColumns(DatabaseMetaData dbMeta, String tableName)
            throws SQLException
    {
        List columns = new ArrayList();
        ResultSet columnSet = null;
        try
        {
            columnSet = dbMeta.getColumns(null, dbSchema, tableName, null);
            while (columnSet.next())
            {
                String name = columnSet.getString(4);
                Integer sqlType = new Integer(columnSet.getString(5));
                Integer size = new Integer(columnSet.getInt(7));
                Integer decimalDigits = new Integer(columnSet.getInt(9));
                Integer nullType = new Integer(columnSet.getInt(11));
                String defValue = columnSet.getString(13);

                List col = new ArrayList(6);
                col.add(name);
                col.add(sqlType);
                col.add(size);
                col.add(nullType);
                col.add(defValue);
                col.add(decimalDigits);
                columns.add(col);
            }
        }
        finally
        {
            if (columnSet != null)
            {
                columnSet.close();
            }
        }
        return columns;
    }

    /**
     * Retrieves a list of the columns composing the primary key for a given
     * table.
     *
     * @param dbMeta JDBC metadata.
     * @param tableName Table from which to retrieve PK information.
     * @return A list of the primary key parts for <code>tableName</code>.
     * @throws SQLException
     */
    public List getPrimaryKeys(DatabaseMetaData dbMeta, String tableName)
            throws SQLException
    {
        List pk = new ArrayList();
        ResultSet parts = null;
        try
        {
            parts = dbMeta.getPrimaryKeys(null, dbSchema, tableName);
            while (parts.next())
            {
                pk.add(parts.getString(4));
            }
        }
        finally
        {
            if (parts != null)
            {
                parts.close();
            }
        }
        return pk;
    }

    /**
     * Retrieves a list of foreign key columns for a given table.
     *
     * @param dbMeta JDBC metadata.
     * @param tableName Table from which to retrieve FK information.
     * @return A list of foreign keys in <code>tableName</code>.
     * @throws SQLException
     */
    public Map getForeignKeys(DatabaseMetaData dbMeta, String tableName)
        throws SQLException
    {
        HashMap fks = new HashMap();
        ResultSet foreignKeys = null;
        try
        {
            foreignKeys = dbMeta.getImportedKeys(null, dbSchema, tableName);
            while (foreignKeys.next())
            {
                String refTableName = foreignKeys.getString(3);
                String fkName = foreignKeys.getString(12);
                int deleteRule = foreignKeys.getInt(11);
                String onDelete = "none";
                if (deleteRule == DatabaseMetaData.importedKeyCascade) {
                	onDelete = "cascade";
                } else if (deleteRule == DatabaseMetaData.importedKeyRestrict) {
                	onDelete = "restrict";
                } else if (deleteRule == DatabaseMetaData.importedKeySetNull) {
                	onDelete = "setnull";
                }
                // if FK has no name - make it up (use tablename instead)
                if (fkName == null)
                {
                    fkName = refTableName;
                }
                Object[] fk = (Object[]) fks.get(fkName);
                List refs;
                if (fk == null)
                {
                    fk = new Object[3];
                    fk[0] = refTableName; //referenced table name
                    refs = new ArrayList();
                    fk[1] = refs;
                    fks.put(fkName, fk);
                    fk[2] = onDelete;
                }
                else
                {
                    refs = (ArrayList) fk[1];
                }
                String[] ref = new String[2];
                ref[0] = foreignKeys.getString(8); //local column
                ref[1] = foreignKeys.getString(4); //foreign column
                refs.add(ref);
            }
        }
        catch (SQLException e)
        {
            // this seems to be happening in some db drivers (sybase)
            // when retrieving foreign keys from views.
            log("WARN: Could not read foreign keys for Table "
                        + tableName
                        + " : "
                        + e.getMessage(),
                    Project.MSG_WARN);
        }
        finally
        {
            if (foreignKeys != null)
            {
                foreignKeys.close();
            }
        }
        return fks;
    }
    
    public List<TableIndex> getIndexes( DatabaseMetaData dbMeta, String tableName ) throws SQLException {
    	List<TableIndex> indexes = new ArrayList<TableIndex>();
    	ResultSet pkInfo = null;
    	String pkName = null;
    	//ArrayList<String> pkFields = new ArrayList<String>();
    	ResultSet indexInfo = null;
    	try {
    		indexInfo = dbMeta.getIndexInfo( null, dbSchema, tableName, false, false );
    		// need to ensure that the PK is not returned as an index
    		pkInfo = dbMeta.getPrimaryKeys( null, dbSchema, tableName );
    		if ( pkInfo.next() ) {
    			pkName = pkInfo.getString( "PK_NAME" );
    		}
    		//Map<Integer,String> tempPk = new HashMap<Integer,String>(); 
    		//while ( pkInfo.next() ) {
    		//	tempPk.put( pkInfo.getInt( "KEY_SEQ" ), pkInfo.getString( "COLUMN_NAME" ) );
    		//}
    		
    		TableIndex currIndex = null;
    		while ( indexInfo.next() ) {
    			if ( indexInfo.getString( "INDEX_NAME" ) == null ) continue;
    			//System.out.println( "Row: " + indexInfo.getString( "INDEX_NAME" ) + "/" + indexInfo.getString( "COLUMN_NAME" ) );
    			if ( currIndex == null || !indexInfo.getString( "INDEX_NAME" ).equals( currIndex.name ) ) {
    				currIndex = new TableIndex();
    				currIndex.name = indexInfo.getString( "INDEX_NAME" );
    				currIndex.unique = !indexInfo.getBoolean( "NON_UNIQUE" );
    				// if has the same name as the PK, skip adding it to the index list
    				if ( pkName == null || !pkName.equals( currIndex.name ) ) {
    					indexes.add( currIndex );
    					//System.out.println( "Added " + currIndex.name + " to index list");
    				} else {
    					//System.out.println( "Skipping PK: " + currIndex.name );
    				}
    			}
    			currIndex.columns.add( indexInfo.getString( "COLUMN_NAME" ) );
    		}
    		
    	} catch (SQLException e) {
            log("WARN: Could not read indexes for Table "
                    + tableName
                    + " : "
                    + e.getMessage(),
                Project.MSG_WARN);
		} finally {
			if ( indexInfo != null ) {
				indexInfo.close();
			}
			if ( pkInfo != null ) {
				pkInfo.close();
			}
		}
		return indexes;
    }
	
    private static class TableIndex {
    	public String name;
    	public boolean unique;
    	public List<String> columns = new ArrayList( 10 );
    }
}
